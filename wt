#!/bin/bash
# git worktree management

set -e

# Version information
WT_VERSION="0.0.0-beta"

# Get current directory name (e.g., ws.wakumo.ai)
DIR_NAME=$(basename "$(pwd)")

# Default worktree directory
TMP_DIR="${HOME}/.wt/worktrees"

case "$1" in
    add)
        if [ -z "$2" ]; then
            echo "Usage: $0 add <name>"
            exit 1
        fi

        NAME="$2"
        # Sanitize branch name for directory use (replace / and other invalid chars with _)
        SAFE_NAME=$(echo "$NAME" | sed 's/[\/\\:*?"<>|]/_/g')
        WORKTREE_DIR="${TMP_DIR}/${DIR_NAME}-${SAFE_NAME}"

        # Create .wt directory and .gitignore if they don't exist
        if [ ! -d ".wt" ]; then
            mkdir -p .wt
            cat > .wt/.gitignore << 'EOF'
worktrees
*.local
EOF
        fi

        # Create .wt/setup template if it doesn't exist
        if [ ! -f ".wt/setup" ]; then
            cat > .wt/setup << 'EOF'
#! /bin/bash
# $ROOT_WORKTREE_PATH is path to the base repository (source tree)
if [ -f .wt/setup.local ]; then
  source .wt/setup.local
fi
EOF
        fi

        mkdir -p .wt/worktrees

        # Check if worktree already exists
        if git worktree list --porcelain | grep -q "worktree $WORKTREE_DIR"; then
            echo "Worktree already exists at $WORKTREE_DIR"
            exit 1
        fi

        # Check if branch exists
        if git branch --list "$NAME" | grep -q "$NAME"; then
            echo "Branch '$NAME' already exists. Adding worktree without -b flag."
            git worktree add "$WORKTREE_DIR" "$NAME"
        else
            echo "Creating new branch '$NAME' and adding worktree."
            git worktree add "$WORKTREE_DIR" -b "$NAME"
        fi

        # Create symlink in .wt/worktrees directory
        SYMLINK_PATH=".wt/worktrees/${SAFE_NAME}"
        if [ -e "$SYMLINK_PATH" ]; then
            echo "Symlink already exists at $SYMLINK_PATH"
            exit 1
        fi

        ln -s "$WORKTREE_DIR" "$SYMLINK_PATH"
        echo "Created worktree at $WORKTREE_DIR"
        echo "Created symlink $SYMLINK_PATH -> $WORKTREE_DIR"

        # Run setup script if it exists in project (from parent repository)
        if [ -f ".wt/setup" ]; then
            echo "Running setup script..."
            ROOT_WORKTREE_PATH="$(pwd)" bash ".wt/setup"
            echo "Setup script completed"
        fi
        ;;
    remove|rm)
        FORCE_FLAG=""
        NAME=""
        
        # Parse arguments
        while [ $# -gt 1 ]; do
            case "$2" in
                -f|--force)
                    FORCE_FLAG="-f"
                    shift
                    ;;
                *)
                    if [ -z "$NAME" ]; then
                        NAME="$2"
                    fi
                    shift
                    ;;
            esac
        done

        if [ -z "$NAME" ]; then
            echo "Usage: $0 remove [-f|--force] <name>"
            exit 1
        fi

        # Sanitize branch name for directory use (replace / and other invalid chars with _)
        SAFE_NAME=$(echo "$NAME" | sed 's/[\/\\:*?"<>|]/_/g')
        SYMLINK_PATH=".wt/worktrees/${SAFE_NAME}"
        
        # Debug: show what we're checking
        if [ ! -e "$SYMLINK_PATH" ]; then
            # Check if it's a broken symlink
            if [ -L "$SYMLINK_PATH" ]; then
                echo "Found broken symlink at $SYMLINK_PATH"
                rm "$SYMLINK_PATH"
                echo "Removed broken symlink"
                exit 0
            else
                echo "Worktree '$NAME' not found at $SYMLINK_PATH"
                exit 1
            fi
        fi

        # Get actual worktree path
        ACTUAL_WORKTREE_DIR=$(readlink -f "$SYMLINK_PATH" 2>/dev/null)
        
        # If symlink exists but worktree directory doesn't exist, just remove the symlink
        if [ -z "$ACTUAL_WORKTREE_DIR" ] || [ ! -e "$ACTUAL_WORKTREE_DIR" ]; then
            echo "Worktree directory not found, removing orphaned symlink"
            rm "$SYMLINK_PATH"
            echo "Removed orphaned symlink $SYMLINK_PATH"
            exit 0
        fi

        # Remove worktree using git
        echo "Removing worktree at $ACTUAL_WORKTREE_DIR"
        if [ -n "$FORCE_FLAG" ]; then
            if ! git worktree remove -f "$ACTUAL_WORKTREE_DIR"; then
                echo "Failed to remove worktree"
                exit 1
            fi
        else
            if ! git worktree remove "$ACTUAL_WORKTREE_DIR"; then
                echo "Failed to remove worktree (may contain modified files)"
                echo "Use --force flag to force removal"
                exit 1
            fi
        fi
        
        # Verify worktree directory is gone
        if [ -e "$ACTUAL_WORKTREE_DIR" ]; then
            echo "Worktree still exists at $ACTUAL_WORKTREE_DIR"
            echo "Worktree not removed completely"
            exit 1
        fi
        
        # Remove symlink since worktree removal was successful
        if [ -e "$SYMLINK_PATH" ]; then
            rm "$SYMLINK_PATH"
            echo "Removed symlink $SYMLINK_PATH"
        fi
        
        echo "Worktree removed successfully"
        ;;
    list)
        git worktree list
        ;;
    go)
        if [ -z "$2" ]; then
            echo "Usage: $0 go <name>"
            exit 1
        fi

        NAME="$2"
        # Sanitize branch name for directory use (replace / and other invalid chars with _)
        SAFE_NAME=$(echo "$NAME" | sed 's/[\/\\:*?"<>|]/_/g')
        WORKTREE_DIR="${TMP_DIR}/${DIR_NAME}-${SAFE_NAME}"
        SYMLINK_PATH=".wt/worktrees/${SAFE_NAME}"

        # Create .wt directory and .gitignore if they don't exist
        if [ ! -d ".wt" ]; then
            mkdir -p .wt
            cat > .wt/.gitignore << 'EOF'
worktrees
*.local
EOF
        fi

        # Create .wt/setup template if it doesn't exist
        if [ ! -f ".wt/setup" ]; then
            cat > .wt/setup << 'EOF'
#! /bin/bash
# wt - Git Worktree Management Tool
# https://github.com/tumf/wt
# $ROOT_WORKTREE_PATH is path to the base repository (source tree)
EOF
        fi

        mkdir -p .wt/worktrees

        # Check if worktree already exists
        WORKTREE_EXISTS=false
        IS_PRUNABLE=false
        
        if git worktree list --porcelain | grep -q "worktree $WORKTREE_DIR"; then
            WORKTREE_EXISTS=true
            # Check if it's prunable (directory doesn't exist)
            if [ ! -d "$WORKTREE_DIR" ]; then
                IS_PRUNABLE=true
                echo "Worktree '$NAME' is marked as prunable, removing stale entry"
                git worktree remove "$WORKTREE_DIR" 2>/dev/null || true
                git worktree prune 2>/dev/null || true
            else
                echo "Worktree '$NAME' exists, navigating to it"
            fi
        fi
        
        # If worktree doesn't exist or was prunable, create it
        if [ "$WORKTREE_EXISTS" = false ] || [ "$IS_PRUNABLE" = true ]; then
            echo "Worktree '$NAME' does not exist, creating it first"

            # Check if branch exists
            if git branch --list "$NAME" | grep -q "$NAME"; then
                echo "Branch '$NAME' already exists. Adding worktree without -b flag."
                git worktree add "$WORKTREE_DIR" "$NAME"
            else
                echo "Creating new branch '$NAME' and adding worktree."
                git worktree add "$WORKTREE_DIR" -b "$NAME"
            fi

            # Create symlink in .wt/worktrees directory
            if [ -e "$SYMLINK_PATH" ]; then
                echo "Symlink already exists at $SYMLINK_PATH, removing old symlink"
                rm "$SYMLINK_PATH"
            fi

            ln -s "$WORKTREE_DIR" "$SYMLINK_PATH"
            echo "Created worktree at $WORKTREE_DIR"
            echo "Created symlink $SYMLINK_PATH -> $WORKTREE_DIR"

            # Run setup script if it exists in project (from parent repository)
            if [ -f ".wt/setup" ]; then
                echo "Running setup script..."
                ROOT_WORKTREE_PATH="$(pwd)" bash ".wt/setup"
                echo "Setup script completed"
            fi
        else
            # Worktree exists and is not prunable, just ensure symlink exists
            if [ ! -e "$SYMLINK_PATH" ]; then
                ln -s "$WORKTREE_DIR" "$SYMLINK_PATH"
                echo "Created symlink $SYMLINK_PATH -> $WORKTREE_DIR"
            fi
        fi

        # Change to worktree directory
        echo "Changing to worktree directory: $WORKTREE_DIR"
        cd "$WORKTREE_DIR" && $SHELL
        ;;
    version|--version|-v)
        echo "wt version $WT_VERSION"
        ;;
    complations)
        echo "Did you mean 'completions'?" >&2
        echo "Usage: $0 completions <bash|zsh|fish|powershell>" >&2
        exit 1
        ;;
    completions)
        SHELL_NAME="$2"
        if [ -z "$SHELL_NAME" ]; then
            echo "Usage: $0 completions <bash|zsh|fish|powershell>"
            echo
            echo "Install instructions:"
            echo "- bash:        wt completions bash > ~/.local/share/bash-completion/completions/wt (or /etc/bash_completion.d/wt)"
            echo "- zsh:         wt completions zsh > ~/.zsh/completions/_wt; echo 'fpath+=(~/.zsh/completions)' >> ~/.zshrc; autoload -Uz compinit && compinit"
            echo "- fish:        wt completions fish > ~/.config/fish/completions/wt.fish"
            echo "- powershell:  wt completions powershell | Out-String | Invoke-Expression (or save to your profile)"
            exit 1
        fi
        case "$SHELL_NAME" in
            bash)
                cat <<'EOF'
# bash completion for wt
_wt()
{
    local cur prev
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    local subs="add remove rm list go run version completions"
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=( $(compgen -W "$subs" -- "$cur") )
        return 0
    fi
    case "${COMP_WORDS[1]}" in
        remove|rm)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=( $(compgen -W "--force -f" -- "$cur") )
            else
                local names
                names=$(git worktree list 2>/dev/null | sed -n 's/.*\[\([^]]*\)\].*/\1/p' | sort -u)
                if [ -z "$names" ]; then
                    names=$(command ls -1 .wt/worktrees 2>/dev/null)
                fi
                COMPREPLY=( $(compgen -W "$names" -- "$cur") )
            fi
            ;;
        go|add|run)
            local names
            names=$(git worktree list 2>/dev/null | sed -n 's/.*\[\([^]]*\)\].*/\1/p' | sort -u)
            if [ -z "$names" ]; then
                names=$(command ls -1 .wt/worktrees 2>/dev/null)
            fi
            COMPREPLY=( $(compgen -W "$names" -- "$cur") )
            ;;
        completions)
            COMPREPLY=( $(compgen -W "bash zsh fish powershell" -- "$cur") )
            ;;
        *) ;;
    esac
}
complete -F _wt wt ./wt
EOF
                ;;
            zsh)
                cat <<'EOF'
#compdef wt ./wt

local -a names

_wt_get_worktrees() {
  names=(${(f)"$(git worktree list 2>/dev/null | sed -n 's/.*\[\([^]]*\)\].*/\1/p' | sort -u)"})
  if [[ ${#names} -eq 0 ]]; then
    names=(${(f)"$(command ls -1 .wt/worktrees 2>/dev/null)"})
  fi
}

if [[ $CURRENT -eq 2 ]]; then
  # Completing subcommand (first argument)
  local -a subcommands
  subcommands=(
    'add:Add a worktree'
    'remove:Remove a worktree'
    'rm:Alias of remove'
    'list:List worktrees'
    'go:Create or navigate to worktree'
    'run:Run command in worktree'
    'version:Show version'
    'completions:Generate shell completion script'
  )
  _describe 'command' subcommands
elif [[ $CURRENT -eq 3 ]]; then
  # Completing argument to subcommand
  case $words[2] in
    add|go|remove|rm|run)
      _wt_get_worktrees
      _describe 'worktree' names
      ;;
    completions)
      _values 'shell' bash zsh fish powershell
      ;;
  esac
fi
EOF
                ;;
            fish)
                cat <<'EOF'
# fish completion for wt
complete -c wt -f
complete -c wt -n '__fish_use_subcommand' -a add -d 'Add a worktree'
complete -c wt -n '__fish_use_subcommand' -a remove -d 'Remove a worktree'
complete -c wt -n '__fish_use_subcommand' -a rm -d 'Alias of remove'
complete -c wt -n '__fish_use_subcommand' -a list -d 'List worktrees'
complete -c wt -n '__fish_use_subcommand' -a go -d 'Create or navigate to worktree'
complete -c wt -n '__fish_use_subcommand' -a run -d 'Run command in worktree'
complete -c wt -n '__fish_use_subcommand' -a version -d 'Show version'
complete -c wt -n '__fish_use_subcommand' -a completions -d 'Generate shell completion script'
# remove flags
complete -c wt -n '__fish_seen_subcommand_from remove' -s f -l force -d 'Force removal'
complete -c wt -n '__fish_seen_subcommand_from rm' -s f -l force -d 'Force removal'
# worktree names for relevant subcommands
set -l __wt_names (git worktree list 2>/dev/null | sed -n 's/.*\[\([^]]*\)\].*/\1/p' | sort -u)
if test -z "$__wt_names"
    set __wt_names (command ls -1 .wt/worktrees 2>/dev/null)
end
complete -c wt -n '__fish_seen_subcommand_from go' -a "$__wt_names"
complete -c wt -n '__fish_seen_subcommand_from add' -a "$__wt_names"
complete -c wt -n '__fish_seen_subcommand_from remove' -a "$__wt_names"
complete -c wt -n '__fish_seen_subcommand_from rm' -a "$__wt_names"
complete -c wt -n '__fish_seen_subcommand_from run' -a "$__wt_names"
# shells for completions
complete -c wt -n '__fish_seen_subcommand_from completions' -a 'bash zsh fish powershell'
EOF
                ;;
            powershell|pwsh|ps)
                cat <<'EOF'
# PowerShell argument completer for wt
Register-ArgumentCompleter -CommandName wt -ScriptBlock {
  param($wordToComplete, $commandAst, $cursorPosition)
  $subs = @('add','remove','rm','list','go','version','completions')
  $tokens = [System.Management.Automation.PSParser]::Tokenize($commandAst.ToString(), [ref]$null)
  $args = @($tokens | Where-Object { $_.Type -in 'CommandArgument','Parameter' } | ForEach-Object Value)
  if ($args.Count -lt 1) {
    $subs | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_) }
    return
  }
  $sub = $args[0]
  switch ($sub) {
    'completions' {
      @('bash','zsh','fish','powershell') | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_) }
    }
    'remove' { goto names }
    'rm'     { goto names }
    'go'     { goto names }
    'add'    { goto names }
    default  { }
  }
  return
  :names
  $names = @()
  try {
    $output = git worktree list 2>$null
    foreach ($line in $output) {
      if ($line -match '\[([^\]]+)\]') {
        $names += $matches[1]
      }
    }
  } catch {}
  if ($names.Count -eq 0) {
    try { $names = Get-ChildItem -Name '.wt/worktrees' -ErrorAction Stop } catch {}
  }
  $names | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object { [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_) }
}
EOF
                ;;
            *)
                echo "Unsupported shell: $SHELL_NAME"
                echo "Supported: bash, zsh, fish, powershell"
                exit 1
                ;;
        esac
        ;;
    ""|*)
        # No subcommand provided, default to list
        git worktree list
        ;;
 esac

